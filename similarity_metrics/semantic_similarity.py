from sklearn.feature_extraction.text import CountVectorizer
import numpy as np
import re

#The sentences are identical so the score should be 1.0
#ground_truth = "I like the blue sky"
#rag_answer = "I like the blue sky"

#The sentences share some words, so the score should be between 0.0 and 1.0
#ground_truth = "I like machine learning"
#rag_answer = "Sky is blue"

def cleaning_txt(text):
    text = text.lower()
    text = re.sub(r"[^\w\s]", "", text)
    return text

#compute cosine similarity function
def cosine_similarity_func(x,y):
    #Ensure two vectors have the same length
    if len(x) != len(y):
        return None

    dot_product = np.dot(x,y)

    #compute magnitudes of x & y
    magnitude_x = np.sqrt(np.sum(x**2))
    magnitude_y = np.sqrt(np.sum(y**2))

    cosine_similarity = dot_product / (magnitude_x * magnitude_y)

    return cosine_similarity 


ground_truth=[  "Associate Sites are smaller-scale, independently operated racks connected to the Chameleon core infrastructure, allowing other institutions to contribute unique hardware resources to the testbed.",
        "The gpu_rtx_8000 nodes are equipped with NVIDIA Quadro RTX 8000 GPUs, each with 48GB of memory.",
        "In the Chameleon Portal, navigate to the 'Network' section and click 'Networks'. Select 'Create Network', give it a name, and then create a subnet within it, specifying an address range (e.g., 192.168.1.0/24).",
        "Log in to the Chameleon JupyterHub. In the launcher, you can browse pre-made notebooks under 'Notebooks' or 'Tutorials' which cover topics like basic Chameleon usage, machine learning, and networking.",
        "This can sometimes happen. The first step is to check the node's remote console from the Chameleon UI for any error messages during boot. If there are no clear errors, try deleting the instance and launching it again. If the problem persists, you should open a support ticket.",
        "This typically means your openrc.sh file is not sourced correctly or has expired credentials. Re-download your openrc.sh v3 file from the Chameleon UI, source it again with source <your-openrc-file.sh>, and enter your password when prompted.",
        "CHI-in-a-Box is a packaged version of the Chameleon infrastructure (CHI) that allows other institutions to build their own Chameleon-like private cloud, capable of federating with the main testbed.",
        "Deep reconfigurability means researchers can go beyond virtual machines and get bare metal access to hardware. This allows them to interact with and modify low-level systems like the operating system kernel, networking configurations, and even firmware on some hardware.",
        "A Private IP is an internal address used for communication between instances on the same private network. A Floating IP is a public, internet-routable IP address that you can associate with an instance to make it reachable from the outside world.",
        "Use a GPU node for massively parallel workloads like machine learning, scientific simulations, or data analytics. Use an FPGA (Field-Programmable Gate Array) node when your experiment requires designing and testing custom digital logic circuits or hardware accelerators.",
        "You should cite the primary paper: 'Chameleon: A Large-Scale, Reconfigurable Experimental Environment for Cloud Research. Jason Anderson, et al.' and include your project ID. The specific BibTeX entry is available in the documentation.",
        "First, create a volume under the 'Volumes' tab in the UI. Then, while the volume is unattached, find your running instance, select 'Attach Volume' from its dropdown menu, and choose the volume you created. The system will then attach it as a new block device (e.g., /dev/vdb).",
        "The maximum length for a single lease is typically 7 days. For longer experiments, you need to chain multiple reservations or contact support for special arrangements.",
        "No. The Chameleon Acceptable Use Policy strictly prohibits using the testbed for any commercial activity, including cryptocurrency mining. Allocations are for open computer science research and education only.",
        "You can create a custom disk image. Start by launching a base OS image on a bare metal node, install the desired kernel and any other software, and then create a snapshot of the node's disk. This snapshot image can then be used to launch other nodes with your custom configuration.",
        "Trovi is Chameleon's artifact sharing portal. It allows users to package, share, and reproduce entire experiments, including Jupyter notebooks, disk images, and orchestration templates, making research more discoverable and repeatable.",
        "You write a YAML-based Heat Orchestration Template (HOT) that defines all the resources (servers, networks, volumes). Then you launch the entire stack from the GUI under 'Orchestration' -> 'Stacks' or via the CLI with openstack stack create.",
        "The two core sites for the Chameleon testbed are at the University of Chicago (UC) and the Texas Advanced Computing Center (TACC).The two core sites for the Chameleon testbed are at the University of Chicago (UC) and the Texas Advanced Computing Center (TACC).",
        "Check the security group rules associated with your instance. Ensure there is an 'egress' rule that allows outbound traffic. The default security group usually allows all egress, but a custom one might not.",
        "Find the experiment on the Trovi artifact repository, which is often linked from the blog post. Import the artifact into your Chameleon account. This will typically give you the Jupyter notebook, scripts, and environment needed to re-run the experiment with a few clicks."]



rag_answer=["The purpose of Chameleon Associate Sites is to extend Chameleon Cloud’s experimental capabilities by partnering with additional institutions that host their own hardware resources.These sites: Expand geographic reach so more researchers have nearby access to advanced testbed resources. Provide specialized hardware or unique environments not available on Chameleon’s core sites (e.g., novel accelerators, edge devices, or specific storage/network configurations). Support community growth by enabling local institutions to participate in the Chameleon ecosystem, contribute hardware, and share expertise. Increase capacity for running experiments by adding more compute, storage, and network resources. Essentially, they let Chameleon grow beyond its main facilities, giving researchers more variety and availability for their experiments.",
        "I couldn’t find any specific mention of hardware labeled exactly as 'gpu_rtx_8000' in Chameleon Cloud’s documentation or public announcements—so the exact node designation might not exist or might be undocumented. That said, if “gpu_rtx_8000” refers to nodes featuring NVIDIA GPUs similar to the RTX A6000 or Quadro RTX 8000 in professional-grade compute testbeds, then it's reasonable to assume theGPU model is the NVIDIA Quadro RTX 8000, but this is an assumption in absence of explicit confirmation. The Quadro RTX 8000 is based on NVIDIA’s Turing architecture. It features: 4,608 CUDA cores 576 Tensor cores 72 RT cores 48 GB GDDR6 memory (ECC-enabled)672 GB/s memory bandwidth PCIe 3.0 x16 interface Up to ~16.3 TFLOPS FP32 performance However, for Chameleon-hosted nodes, the GPU models explicitly documented are: A100 PCIe 80 GB GPUs on GigaIO systems at CHI@UC A100 (PCIe 40 GB) and A30 (GA100GL) GPUs at CHI@TACC To get a definitive answer, I recommend checking the Chameleon Hardware Discoveryinterface or the Chameleon documentation or help desk—this is the most reliable way to identify the actual GPU model used in a specific node labeled 'gpu_rtx_8000.'",
        "On Chameleon Cloud, you can create an isolated network for your instances via the Horizon web GUI by following these steps: 1. Log in Go to https://chi.tacc.chameleoncloud.org or your site’s Horizon dashboard URL. Log in with your Chameleon credentials.2. Navigate to the Network section In the left-hand menu, click Network → Networks. Click Create Network. 3. Configure the network In the Create Network dialog: Network tab Name: Enter a descriptive name (e.g., my-private-net). Leave Admin State checked (enabled).Keep Shared unchecked so only your project can use it. Subnet tab Subnet Name: Name your subnet (e.g., my-private-subnet). Network Address: Enter the CIDR for your subnet (e.g., 192.168.100.0/24). IP Version: Select IPv4. Subnet Details tab Uncheck Enable DHCP if you want complete control of IP assignments; otherwise, leave it checked.Leave DNS nameservers blank or enter custom ones if needed (e.g., 8.8.8.8). Click Create. 4. (Optional) Add a router for external connectivity If you want the network to have internet access: Go to Network → Routers → Create Router. Name the router and set the External Network (often named public or similar). After creating it, click the router name, go to the Interfaces tab, and Add Interface to your subnet.If you want true isolation (no outside connectivity), skip this step.5. Launch instances on the new network When launching an instance, under the Networks tab, select your isolated network. Make sure you don’t attach a public network or router if you want full isolation.",
        "Here’s how you can find and use a pre-configured Jupyter notebook on Chameleon Cloud:1. Go to Chameleon’s JupyterHub Visit: https://jupyter.chameleoncloud.org Log in with your Chameleon credentials (via Globus or institutional login). 2. Launch a pre-configured environment After logging in, you’ll see a 'Start My Server' page.In the Server Options, select a pre-configured environment.Examples: Python Data Science, HPC, TensorFlow, etc. These environments already have common packages installed and are set up for Chameleon. Choose your compute site (e.g., CHI@TACC, CHI@UC) and instance type. 3. Access example notebooks Once the Jupyter environment launches, look for:A examples/ or notebooks/ folder in your home directory. Or click File → Open… and browse to /examples or /shared. Chameleon provides preloaded example notebooks for things like: OpenStack automation Networking experiments Machine learning demos Hardware control 4. Run the notebook Open a notebook (.ipynb file) by clicking it.Run cells with Shift+Enter. You can edit the notebook to fit your experiment. 5. Save your work Save your modified notebook in your home directory so it persists between sessions. You can also download itto your local machine via File → Download As → Notebook (.ipynb). Tip: If you don’t see the notebook you expect, you can also pull it from Chameleon’s GitHub repo directly inside Jupyter with:git clone https://github.com/ChameleonCloud/notebooks.git",
        "If your bare metal node on Chameleon is stuck in 'deploying' for much longer than usual, here’s the recommended approach: 1. Wait the normal window Bare metal provisioning typically takes 5–15 minutes, sometimes up to 30 minutes for large images. If it’s been over 30–45 minutes, it’s likely stuck. 2. Check the instance logs Go to Project → Compute → Instances in the Horizon GUI. Click your instance name → Log tab.Look for errors related to PXE boot, disk imaging, or network. 3. Try to rebuild the instance In the instance’s Actions menu, select Rebuild. Choose the same image and flavor (or try a smaller image to test). This forces the provisioning process to restart. 4. Delete and re-launch If rebuild doesn’t work: Delete the instance. Wait a few minutes so the node is fully released. Launch it again — preferably on a different node if the scheduler allows. 5. Check resource availability Sometimes the site is under heavy load or has a faulty node. In the GUI, go to Project → Compute → Bare Metal → Nodes to see the node’s status (if you have permission). 6. Contact Chameleon Support If it’s still stuck: Open a ticket at https://www.chameleoncloud.org/user/help/ Provide: Instance ID Reservation ID (if using a reserved node) Time you launched it Image and flavor A short description of the problem  Tip: Sometimes a stuck 'deploying' happens because the node didn’t properly release from a previous user’s experiment — support staff can manually reset it.",
        "On Chameleon, an 'Error 403: Forbidden' when using the OpenStack CLI usually means your CLI is authenticating correctly but you don’t have permission to perform the requested action.Here’s how to troubleshoot it step-by-step: 1. Check your credentials Make sure you downloaded the correct OpenRC file for your Chameleon project and site: Go to the Horizon GUI → API Access → Download OpenStack RC File. Source it before running CLI commands: source ~/Downloads/project-openrc.sh Enter your Chameleon password when prompted. 2. Verify your active project You may belong to multiple projects; if you’re in the wrong one, you won’t have permissions. Run: openstack token issue Check the project_id and project_name match your intended project.3. Confirm your role in the project Only users with the correct role (e.g., admin, member) can run certain commands like creating networks, routers, or security groups. If you need extra permissions, contact your project PI or Chameleon support. 4. Make sure you’re using the right site Chameleon has multiple sites (CHI@TACC, CHI@UC, etc.). If your OpenRC file points to CHI@UC, you can’t manage resources at CHI@TACC. You must download and source the RC file for the specific site. 5. Check command scope Some commands require admin privileges that are not available to standard users (e.g., listing all hypervisors). If you’re running a command that’s restricted, you’ll get 403. 6. Contact Support if all above is correct If credentials, project, site, and role are all correct, it could be: A temporary policy misconfiguration. A bug in the CLI endpoint. Open a ticket with:Exact CLI command you ran. Full error output. Site name and project ID.",
        "CHI-in-a-Box is Chameleon Cloud’s packaged version of its Chameleon Infrastructure (CHI) that you can deploy on your own hardware.In other words, it’s a self-contained, installable OpenStack-based testbed that reproduces the same software stack Chameleon runs at its main sites, but sized and configured for smaller, local clusters. Main purposes Reproduce Chameleon’s environment locally for development, testing, or teaching. Experiment with new hardware or network topologies without using main-site resources. Train users on the Chameleon/OpenStack workflow in a controlled setting. Key features Preconfigured to match Chameleon’s APIs and tools. Can manage bare metal, virtual machines, and containers. Includes network isolation, image management, and reservation support. Uses Ansible playbooks for installation and configuration. Typical uses University labs running small-scale cloud testbeds. Developers testing new CHI features before deploying to production. Researchers prototyping experiments before running them on large Chameleon nodes.",
        "For Chameleon Cloud, “deep reconfigurability” means that the testbed lets you reconfigure not just software, but also low-level system and hardware components — all the way down to bare metal — so you can run experiments that would be impossible on a standard public cloud.Key aspects Bare metal access You get full control of a physical node — no hypervisor layer between you and the hardware. Lets you modify BIOS/firmware settings, install custom kernels, or change OS images entirely. Custom networking You can design your own isolated networks, set up software-defined networking (SDN), and control routing/switching for experiments. Specialized hardware control Access to FPGAs, GPUs, high-speed interconnects, and experimental storage devices — and the ability to reconfigure them. Software stack flexibility You’re free to install custom drivers, OS distributions, libraries, or experimental software without the restrictions typical clouds impose. Why it matters Enables systems research (e.g., new schedulers, storage stacks, or network protocols). Supports hardware–software co-design experiments. Lets researchers test ideas under realistic performance conditions, without virtualization overhead.In short — deep reconfigurability means Chameleon isn’t just 'cloud servers you can log into.' It’s a testbed where you can reshape the entire stack — hardware through software — to fit your experiment.",
        "On Chameleon Cloud (and OpenStack in general), the difference between a Floating IP and a Private IP comes down to network scope and accessibility: 1. Private IP Scope: Internal to your OpenStack project’s network. Purpose: Lets instances communicate with each other inside your project (and sometimes within the site) without touching the public internet. Assigned: Automatically when you attach an instance to a private network. Accessible from: Other instances in the same network/project. Not directly reachable from the internet. Example: 192.168.x.x or 10.x.x.x 2. Floating IP Scope: Publicly routable on the internet. Purpose: Maps a public IP to one of your instance’s private IPs so it can be accessed from outside Chameleon.Assigned: You reserve a floating IP from the public pool and associate it with an instance. Accessible from: Anywhere on the internet (assuming security groups/firewall rules allow it). Example: 129.x.x.x (real, public IPv4) Key difference in behavior Private IP: Like your computer’s LAN IP at home — local only.Floating IP: Like your ISP-assigned public IP — visible to the outside world.  Tip: In Chameleon, you usually SSH into an instance using its Floating IP, but inside the cloud you connect instance-to-instance using Private IPs for lower latency and no public bandwidth usage.",
        "Here’s the short version: use an FPGA node when you need custom, reconfigurable hardware logic, and use a GPU node when you need massively parallel numeric processing. FPGA nodes (Field-Programmable Gate Arrays) Best for: Custom hardware acceleration for specialized algorithms (e.g., encryption/decryption, packet processing, signal processing). Low-latency workloads where deterministic timing is important. Prototyping and testing new hardware architectures. Applications where power efficiency is critical for a specific computation pattern. Why: You can program the FPGA’s logic gates to execute tasks in hardware instead of software. Ideal for non-standard workloads that can’t be efficiently expressed in GPU shaders/kernels. Examples: real-time analytics on streaming data, networking appliances, custom AI inference logic. GPU nodes (Graphics Processing Units) Best for: Parallelizable numerical workloads like deep learning, scientific simulations, image/video processing.High-throughput linear algebra, matrix multiplications, and floating-point calculations. Frameworks like TensorFlow, PyTorch, CUDA, or OpenCL.Why: Thousands of small cores optimized for SIMD (single instruction, multiple data) execution. Best when the computation is well-suited to batch processing large datasets in parallel.Examples: training a neural network, rendering, large-scale fluid dynamics simulations. Rule of thumb FPGA: You need custom circuitry for specialized or unusual tasks — hardware-level customization is the priority. GPU: You need raw parallel compute power for data-heavy, math-heavy tasks — software-level programming is the priority.",
        "Standard Chameleon citation From the Chameleon documentation:Kate Keahey, Pierre Riteau, Dan Stanzione, Paul Rad, Joe Mambretti, Joe Stubbs, Jason Anderson, Pierre-François Dutot, Paul Ruth, Alex Withers, Dan K. Brown, “Chameleon: a Scalable Production Testbed for Computer Science Research,” Contemporary High Performance Computing: From Petascale toward Exascale, Volume 3, Chapman and Hall/CRC Computational Science, 2018. doi:10.1201/9781315151784-1 BibTeX format @incollection{keahey2018chameleon,title={Chameleon: a Scalable Production Testbed for Computer Science Research}, author={Keahey, Kate and Riteau, Pierre and Stanzione, Dan and Rad, Paul and Mambretti, Joe and Stubbs, Joe and Anderson, Jason and Dutot, Pierre-François and Ruth, Paul and Withers, Alex and Brown, Dan K.}, booktitle={Contemporary High Performance Computing: From Petascale toward Exascale, Volume 3}, pages={123--148}, year={2018}, publisher={Chapman and Hall/CRC}, doi={10.1201/9781315151784-1}} Acknowledgment statement If your work used Chameleon resources, include: This research used resources of the Chameleon testbed, supported by the National Science Foundation.",
        "Here’s how to attach a volume to a running instance on Chameleon using the Horizon GUI: 1. Create or locate your volume Go to Project → Volumes → Volumes. If you already have a volume, skip to step 2. To create one: Click Create Volume. Enter a Name, Size (GB), and optionally select a Volume Source (blank, image, snapshot). Click Create Volume. 2. Attach the volume to your instance Still in Project → Volumes → Volumes, find your volume in the list.In the Actions column, click Manage Attachments. Under Attach to Instance, choose your running instance from the dropdown. Click Attach Volume. 3. Log into your instance SSH into your instance using its Floating IP. 4. Identify the volume inside the instance Run: lsblk You’ll see the new block device (e.g., /dev/vdb) that wasn’t there before. 5. Format and mount (first-time use) If it’s a brand new volume: sudo mkfs.ext4 /dev/vdb sudo mkdir /mnt/myvolume sudo mount /dev/vdb /mnt/myvolume 6. Make it persistent (optional) To automatically mount it on reboot, add an entry in /etc/fstab: echo '/dev/vdb /mnt/myvolume ext4 defaults 0 0' | sudo tee -a /etc/fstab Tip: Detaching works the same way — in Manage Attachments, select Detach Volume before deleting or reattaching it.",
        "On Chameleon Cloud, the maximum duration for a single lease reservation is 7 days. After that: You can extend the lease (if resources are available) from the Horizon GUI or via the CLI. For longer-running experiments, the recommended workflow is to chain multiple reservations or periodically renew before expiration. This 7-day limit helps ensure fair access to limited bare metal and specialized hardware.",
        "No — Chameleon Cloud’s Acceptable Use Policy explicitly prohibits using its resources for cryptocurrency mining. Mining isn’t allowed because: It provides no research value aligned with Chameleon’s NSF-funded mission. It consumes significant compute, power, and cooling resources that are meant for scientific and educational experiments. It can cause scheduling delays for legitimate research workloads. If you run mining workloads, your allocation can be suspended or revoked. Chameleon resources are intended only for open, publishable research and education projects.",
        "Here’s how you can set up an experiment on Chameleon that requires a specific Linux kernel version on a bare metal node: 1. Reserve a bare metal node Use the Horizon GUI or CLI to create a lease for the hardware you need. Make sure you select the right site (CHI@TACC, CHI@UC, etc.) and node type. 2. Choose a base image If Chameleon already provides an image with the kernel you want, you can use it directly. Otherwise, start from a standard Chameleon-provided image (e.g., CentOS, Ubuntu). 3. Install the specific kernel Once the node is active, SSH in and install your desired kernel: For Ubuntu/Debian: sudo apt update sudo apt install linux-image-<version> For CentOS/RHEL: sudo yum install kernel-<version> To see available versions: apt-cache search linux-image # or yum list kernel 4. Set the default kernel After installation, update the bootloader to use your kernel by default: Ubuntu/Debian: sudo grub-set-default 0 sudo update-grub CentOS/RHEL: sudo grub2-set-default 0 sudo grub2-mkconfig -o /boot/grub2/grub.cfg (0 here is the index of the kernel in the boot menu; you can adjust it.) 5. Reboot and verify sudo reboot uname -r Confirm that the output matches your target kernel version. 6. (Optional) Create a custom image If you’ll repeat this experiment later: Use cc-snapshot (or Horizon’s Create Snapshot function) to save your configured node as a reusable image. That way, you won’t have to reinstall the kernel each time. Tip: Since Chameleon gives you bare metal access, you can even build and boot a custom-compiled kernel from source if the version you need isn’t in the package repositories.",
        "The Trovi artifacts repository is Chameleon Cloud’s platform for sharing and discovering experiment artifacts — things like datasets, code, images, configurations, and documentation that make research reproducible. Key purposes Publish your work so others can rerun or build on it. Find ready-to-use artifacts from other Chameleon users to speed up your own experiments. Support reproducibility by bundling the exact inputs, code, and instructions needed to replicate results. What you can store Source code (Git repos or archives) Prebuilt images (VM or bare metal snapshots) Experiment configurations and scripts Datasets or synthetic data generators Documentation / “how-to” instructions How it works Create an artifact in Trovi (via the Chameleon web portal). Upload files or link to external repositories. Add metadata: title, description, tags, authors, license. Choose visibility: private (project only), shared with specific users, or public. Other users can discover it via search or tags and launch it directly onto Chameleon resources. Why it’s useful Encourages open science and data sharing. Lets you reproduce past experiments exactly, even months or years later. Helps meet reproducibility requirements for conferences/journals.",
        "You can do it with a single Heat (OpenStack Orchestration) template using a ResourceGroup that repeats an OS::Nova::Server definition N times. Here’s a minimal, copy‑pasteable example that launches any number of identical nodes: # multi-nodes.yaml heat_template_version: 2016-10-14 description: Launch N identical instances on Chameleon parameters: count: type: number default: 3 description: How many instances to launch image: type: string description:Image name or ID (e.g., CC-Ubuntu22.04) flavor: type: string description: Flavor name (e.g., baremetal, compute_skylake, gpu_a100, etc.) network: type: string description: Network name or ID to attach (your private network key_name: type: string description: Keypair to inject for SSH security_group: type: string default: default description: Security group name resources: servers: type: OS::Heat::ResourceGroup properties: count: { get_param: count } resource_def: type: OS::Nova::Server properties: # Use the ResourceGroup index to make unique names name: str_replace: template: node-%index% params: { } image: { get_param: image } flavor: { get_param: flavor } key_name: { get_param: key_name } networks: - network: { get_param: network }security_groups: - { get_param: security_group } user_data_format: RAW user_data: |#cloud-config package_update: true runcmd:- echo 'hello from $(hostname)' > /etc/motd outputs: instance_names: description: Instance names created value: { get_attr: [servers, attributes, name] } Launch with one command Replace parameter values with what you use on Chameleon (image/flavor/network names or IDs): openstack stack create \ --template multi-nodes.yaml \ --parameter count=5 \ --parameter image='CC-Ubuntu22.04' \ --parameter flavor='compute_skylake' \ --parameter network='my-private-net' \--parameter key_name='mykey' \--parameter security_group='default' \ my-multi-stack Check progress and outputs:openstack stack list openstack stack show my-multi-stack -f yaml Notes & tips Works for VM and bare metal flavors—Heat/Nova treats bar metal nodes similarly (just pick a bare‑metal flavor).To add Floating IPs, create ports and a OS::Neutron::FloatingIP + FloatingIPAssociation in the resource_def (one per index). To run different init commands, edit the user_data cloud‑init block. Delete everything at once with: openstack stack delete --yes my-multi-stack",
        "Chameleon Cloud’s two main hardware sites are: CHI@TACC – at the Texas Advanced Computing Center in Austin, Texas CHI@UC – at the University of Chicago in Chicago, Illinois These are the large-scale core facilities where most of Chameleon’s compute, storage, and network resources are hosted. Additional Associate Sites at other institutions contribute specialized hardware, but CHI@TACC and CHI@UC are the primary operational sites.",
        "If your Chameleon instance has a floating IP but still can’t access the internet, it’s usually because something is missing between the public network and your instance. Here’s the checklist to debug it: 1. Security groups Floating IPs can be assigned, but traffic will be blocked unless allowed by security group rules. Go to Project → Network → Security Groups, edit the group attached to your instance, and add: Egress rules for all IPs (0.0.0.0/0) Ingress rules for SSH (port 22) and any other needed ports If you need full outbound internet access, allow egress TCP/UDP on 80, 443, etc. 2. Router configuration In Chameleon, your private network must connect to the public network through a router:Go to Project → Network → Routers. Ensure the router has an External Gateway set to the public network. Make sure your private subnet is added as an interface on that router. Without this, packets from your instance won’t reach the internet. 3. Instance network configInside your instance, check: ip addr ip route Make sure: The private IP is assigned to the correct interface. The default route points to the subnet’s gateway. 4. Floating IP association In Project → Compute → Instances, verify the floating IP is associated with the right port (the instance’s port on the private network). 5. DNS settings If pings to public IPs work but domain names fail, add DNS servers: sudo nano /etc/resolv.conf Add: nameserver 8.8.8.8 nameserver 1.1.1.1 6. Site-specific firewall rules Some Chameleon sites block certain outbound ports. If your app uses nonstandard ports, check the site documentation. Quick test: Run inside your instance: ping -c 4 8.8.8.8 # Tests connectivity ping -c 4 google.com# Tests DNS This helps narrow whether it’s a routing or DNS issue.",
        "To repeat a networking experiment from the Chameleon blog and make it fully reproducible, you’ll want to work from the same code, configuration, and hardware setup the authors used. Chameleon’s ecosystem (especially Trovi) makes that easier. 1. Check if there’s a Trovi artifact Many blog experiments link directly to a Trovi artifact.Open the blog post and look for: A 'Launch in Chameleon' button. A Trovi URL (e.g., https://www.chameleoncloud.org/experiment/...). If available: Click the link → log in → launch the artifact. Trovi will automatically set up: The correct image Networking topology Scripts and code Any special packages 2. Follow the exact hardware/network setup If no Trovi artifact: Identify resources used in the blog: Node type/flavor (e.g., compute_skylake, gpu_a100, fpga_xilinx) Network configuration (private network, router, floating IPs) Any leases/reservations used (bare metal, VLANs) Reserve nodes with the same specifications in Chameleon (via GUI or CLI). Recreate the network topology: Use Horizon’s Network → Networks/Routers.Match subnets, IP ranges, and security group rules from the experiment. 3. Get the code and data Many blog experiments link to a GitHub repo. Clone it directly on your Chameleon instance: git clone <repo-url> cd <repo-folder> Check out the commit or tag mentioned in the blog for exact reproducibility: git checkout <commit-hash>4. Match the software environment If the blog specifies a kernel, OS version, or specific packages, install them exactly. Use Conda, virtualenv, or Docker if they were used in the original setup. If they used a Chameleon-provided image, select that image when launching your instance. 5. Run the experiment Follow the blog’s instructions step-by-step. Keep notes on: Parameter values Command output Any deviations from the original steps 6. Save your work for your reproducibility Once it works, create: A snapshot image if you want to preserve your configured node. A Trovi artifact if you want to share your exact reproducible setup with others. Tip: If you send me the link to the specific Chameleon blog post, I can extract the hardware, software, and network specs for you and give you a direct step-by-step reproducibility plan tailored to that experiment."]

        

if __name__ == '__main__':

    for i, (ground_truth, rag_answer) in enumerate(zip(ground_truth, rag_answer),1): 
        ground_truth = cleaning_txt(ground_truth)
        rag_answer = cleaning_txt(rag_answer)

        vector = CountVectorizer().fit_transform([ground_truth, rag_answer]).toarray()
        score = cosine_similarity_func(vector[0], vector[1])
        print(f"test{i}: {score:.4f}")

